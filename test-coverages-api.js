const axios = require('axios');

// Configuraci√≥n
const API_BASE_URL = 'http://localhost:3001/api'; // Cambiar seg√∫n tu configuraci√≥n
const TEST_PROJECT_ID = 'test-api-project-' + Date.now();

// Colores para logs
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(colors[color] + message + colors.reset);
}

// Datos de prueba simulando hallazgos del frontend
const testFindings = [
  {
    id: 'api-finding-1',
    summary: 'Problemas en contrataci√≥n p√∫blica',
    description: 'Proceso de licitaci√≥n sin transparencia adecuada',
    theme: 'Transparencia',
    geographic_info: {
      city: 'Guatemala',
      department: null,
      pais: 'Guatemala'
    }
  },
  {
    id: 'api-finding-2',
    summary: 'Deficiencias en servicios municipales',
    description: 'Recolecci√≥n de basura irregular en sector urbano',
    theme: 'Servicios Municipales',
    geographic_info: {
      city: 'Mixco',
      department: null,
      pais: 'Guatemala'
    }
  },
  {
    id: 'api-finding-3',
    summary: 'Corrupci√≥n en obra p√∫blica',
    description: 'Sobreprecio detectado en construcci√≥n de puente',
    theme: 'Transparencia',
    geographic_info: {
      city: 'Quetzaltenango',
      department: null,
      pais: 'Guatemala'
    }
  }
];

async function testServerConnection() {
  log('\nüîå Probando conexi√≥n al servidor...', 'blue');
  
  try {
    const response = await axios.get(`${API_BASE_URL}/coverages/test`, {
      timeout: 5000
    });
    
    log('‚úÖ Servidor responde correctamente', 'green');
    return true;
  } catch (error) {
    if (error.code === 'ECONNREFUSED') {
      log('‚ùå No se puede conectar al servidor. ¬øEst√° corriendo en puerto 3001?', 'red');
    } else if (error.response) {
      log(`‚ùå Error del servidor: ${error.response.status} - ${error.response.statusText}`, 'red');
    } else {
      log(`‚ùå Error de conexi√≥n: ${error.message}`, 'red');
    }
    return false;
  }
}

async function testAutoDetectEndpoint() {
  log('\nü§ñ Probando endpoint de auto-detect...', 'blue');
  
  try {
    const requestData = {
      project_id: TEST_PROJECT_ID,
      findings: testFindings
    };
    
    log(`üì§ Enviando ${testFindings.length} hallazgos para auto-detect...`, 'cyan');
    
    const response = await axios.post(`${API_BASE_URL}/coverages/auto-detect`, requestData, {
      headers: {
        'Content-Type': 'application/json'
      },
      timeout: 30000 // 30 segundos para operaciones IA
    });
    
    if (response.status === 200) {
      const { created_count, updated_count, total_coverages, coverages } = response.data;
      
      log('‚úÖ Auto-detect ejecutado exitosamente:', 'green');
      log(`  ‚Ä¢ Coberturas creadas: ${created_count}`, 'green');
      log(`  ‚Ä¢ Coberturas actualizadas: ${updated_count}`, 'green');
      log(`  ‚Ä¢ Total de coberturas: ${total_coverages}`, 'green');
      
      if (coverages && coverages.length > 0) {
        log('\nüìã Coberturas generadas:', 'cyan');
        coverages.forEach(coverage => {
          log(`  ‚Ä¢ ${coverage.coverage_type}: ${coverage.name} (${coverage.findings_count} hallazgos)`, 'cyan');
        });
      }
      
      return { success: true, data: response.data };
    } else {
      log(`‚ùå Respuesta inesperada: ${response.status}`, 'red');
      return { success: false, error: 'Unexpected status' };
    }
    
  } catch (error) {
    log(`‚ùå Error en auto-detect: ${error.message}`, 'red');
    if (error.response && error.response.data) {
      log(`   Detalles: ${JSON.stringify(error.response.data)}`, 'red');
    }
    return { success: false, error: error.message };
  }
}

async function testGetCoveragesEndpoint() {
  log('\nüìñ Probando endpoint de obtener coberturas...', 'blue');
  
  try {
    const response = await axios.get(`${API_BASE_URL}/coverages/${TEST_PROJECT_ID}`, {
      timeout: 10000
    });
    
    if (response.status === 200) {
      const coverages = response.data;
      
      log(`‚úÖ Obtenidas ${coverages.length} coberturas`, 'green');
      
      // Agrupar por tipo para an√°lisis
      const byType = coverages.reduce((acc, coverage) => {
        if (!acc[coverage.coverage_type]) acc[coverage.coverage_type] = [];
        acc[coverage.coverage_type].push(coverage);
        return acc;
      }, {});
      
      for (const [type, coveragesList] of Object.entries(byType)) {
        log(`  ‚Ä¢ ${type}: ${coveragesList.length}`, 'cyan');
        coveragesList.forEach(c => {
          log(`    - ${c.name} (${c.findings_count} hallazgos)`, 'cyan');
        });
      }
      
      return { success: true, data: coverages };
    } else {
      log(`‚ùå Error: ${response.status}`, 'red');
      return { success: false, error: 'Unexpected status' };
    }
    
  } catch (error) {
    log(`‚ùå Error obteniendo coberturas: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

async function testUpdateGeographyEndpoint(coverageId) {
  log('\nüó∫Ô∏è Probando endpoint de actualizaci√≥n geogr√°fica...', 'blue');
  
  if (!coverageId) {
    log('‚ö†Ô∏è No hay ID de cobertura para probar actualizaci√≥n', 'yellow');
    return { success: false, error: 'No coverage ID' };
  }
  
  try {
    const updateData = {
      additional_findings: [
        {
          id: 'update-finding-1',
          summary: 'Nuevo hallazgo para actualizaci√≥n',
          description: 'Problema adicional detectado en la misma √°rea',
          theme: 'Servicios P√∫blicos',
          geographic_info: {
            city: 'Guatemala',
            department: 'Guatemala',
            pais: 'Guatemala'
          }
        }
      ]
    };
    
    log(`üîÑ Actualizando cobertura ${coverageId}...`, 'cyan');
    
    const response = await axios.put(`${API_BASE_URL}/coverages/${coverageId}/update-geography`, updateData, {
      headers: {
        'Content-Type': 'application/json'
      },
      timeout: 20000
    });
    
    if (response.status === 200) {
      const { message, coverage } = response.data;
      
      log('‚úÖ Actualizaci√≥n geogr√°fica exitosa:', 'green');
      log(`  ‚Ä¢ ${message}`, 'green');
      log(`  ‚Ä¢ Nuevos hallazgos: ${coverage.findings_count}`, 'green');
      
      return { success: true, data: response.data };
    } else {
      log(`‚ùå Error en actualizaci√≥n: ${response.status}`, 'red');
      return { success: false, error: 'Unexpected status' };
    }
    
  } catch (error) {
    log(`‚ùå Error actualizando geograf√≠a: ${error.message}`, 'red');
    if (error.response && error.response.data) {
      log(`   Detalles: ${JSON.stringify(error.response.data)}`, 'red');
    }
    return { success: false, error: error.message };
  }
}

async function testDuplicateAutoDetect() {
  log('\nüîÅ Probando prevenci√≥n de duplicados con auto-detect...', 'blue');
  
  try {
    // Ejecutar auto-detect por segunda vez con los mismos datos
    const requestData = {
      project_id: TEST_PROJECT_ID,
      findings: testFindings
    };
    
    log('üì§ Enviando los mismos hallazgos por segunda vez...', 'cyan');
    
    const response = await axios.post(`${API_BASE_URL}/coverages/auto-detect`, requestData, {
      headers: {
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
    
    if (response.status === 200) {
      const { created_count, updated_count, total_coverages } = response.data;
      
      log('‚úÖ Segunda ejecuci√≥n completada:', 'green');
      log(`  ‚Ä¢ Nuevas coberturas creadas: ${created_count}`, created_count === 0 ? 'green' : 'yellow');
      log(`  ‚Ä¢ Coberturas actualizadas: ${updated_count}`, updated_count > 0 ? 'green' : 'yellow');
      log(`  ‚Ä¢ Total de coberturas: ${total_coverages}`, 'green');
      
      if (created_count === 0 && updated_count > 0) {
        log('üéØ ¬°Excelente! No se crearon duplicados, solo se actualizaron existentes', 'green');
        return { success: true, noDuplicates: true };
      } else if (created_count > 0) {
        log('‚ö†Ô∏è Se crearon nuevas coberturas cuando no deber√≠a haber duplicados', 'yellow');
        return { success: true, noDuplicates: false };
      }
      
      return { success: true, noDuplicates: true };
    } else {
      log(`‚ùå Error en segunda ejecuci√≥n: ${response.status}`, 'red');
      return { success: false, error: 'Unexpected status' };
    }
    
  } catch (error) {
    log(`‚ùå Error en prueba de duplicados: ${error.message}`, 'red');
    return { success: false, error: error.message };
  }
}

async function cleanup() {
  log('\nüßπ Limpiando datos de prueba de API...', 'yellow');
  
  try {
    // Intentar eliminar coberturas de prueba mediante endpoint
    const response = await axios.delete(`${API_BASE_URL}/coverages/project/${TEST_PROJECT_ID}`, {
      timeout: 10000
    });
    
    if (response.status === 200) {
      log('‚úÖ Datos de prueba eliminados via API', 'green');
    } else {
      log('‚ö†Ô∏è No se pudieron eliminar todos los datos via API', 'yellow');
    }
  } catch (error) {
    log('‚ö†Ô∏è Error al limpiar via API, datos pueden quedar residuales', 'yellow');
  }
}

async function runAPITestSuite() {
  log('üåê INICIANDO PRUEBAS DE LA API DE COBERTURAS', 'magenta');
  log('==============================================', 'magenta');
  
  const results = {
    serverConnection: false,
    autoDetect: { success: false },
    getCoverages: { success: false },
    updateGeography: { success: false },
    duplicatePrevention: { success: false, noDuplicates: false }
  };
  
  try {
    // 1. Conexi√≥n al servidor
    results.serverConnection = await testServerConnection();
    if (!results.serverConnection) {
      log('\n‚ùå Pruebas abortadas: no hay conexi√≥n al servidor', 'red');
      log('üí° Aseg√∫rate de que ExtractorW est√© corriendo con: npm start', 'yellow');
      return results;
    }
    
    // 2. Auto-detect de coberturas
    results.autoDetect = await testAutoDetectEndpoint();
    
    // 3. Obtener coberturas
    results.getCoverages = await testGetCoveragesEndpoint();
    
    // 4. Actualizar geograf√≠a (si hay coberturas disponibles)
    if (results.getCoverages.success && results.getCoverages.data.length > 0) {
      const firstCoverageId = results.getCoverages.data[0].id;
      results.updateGeography = await testUpdateGeographyEndpoint(firstCoverageId);
    }
    
    // 5. Prevenci√≥n de duplicados
    results.duplicatePrevention = await testDuplicateAutoDetect();
    
  } catch (error) {
    log(`\n‚ùå Error general en pruebas de API: ${error.message}`, 'red');
  }
  
  // Resumen final
  log('\nüìã RESUMEN DE PRUEBAS API', 'magenta');
  log('=========================', 'magenta');
  
  log(`‚Ä¢ Conexi√≥n Servidor: ${results.serverConnection ? '‚úÖ' : '‚ùå'}`, results.serverConnection ? 'green' : 'red');
  log(`‚Ä¢ Auto-detect: ${results.autoDetect.success ? '‚úÖ' : '‚ùå'}`, results.autoDetect.success ? 'green' : 'red');
  log(`‚Ä¢ Obtener Coberturas: ${results.getCoverages.success ? '‚úÖ' : '‚ùå'}`, results.getCoverages.success ? 'green' : 'red');
  log(`‚Ä¢ Actualizar Geograf√≠a: ${results.updateGeography.success ? '‚úÖ' : '‚ùå'}`, results.updateGeography.success ? 'green' : 'red');
  log(`‚Ä¢ Prevenci√≥n Duplicados: ${results.duplicatePrevention.success ? '‚úÖ' : '‚ùå'}`, results.duplicatePrevention.success ? 'green' : 'red');
  
  if (results.duplicatePrevention.success) {
    log(`  ‚îî‚îÄ Sin duplicados: ${results.duplicatePrevention.noDuplicates ? '‚úÖ' : '‚ùå'}`, 
        results.duplicatePrevention.noDuplicates ? 'green' : 'yellow');
  }
  
  const allTestsPassed = results.serverConnection && 
                        results.autoDetect.success && 
                        results.getCoverages.success && 
                        results.duplicatePrevention.success &&
                        results.duplicatePrevention.noDuplicates;
  
  log(`\nüéØ RESULTADO API: ${allTestsPassed ? 'TODAS LAS PRUEBAS EXITOSAS ‚úÖ' : 'ALGUNAS PRUEBAS FALLARON ‚ùå'}`, 
      allTestsPassed ? 'green' : 'red');
  
  // Limpiar datos de prueba
  await cleanup();
  
  return results;
}

// Funci√≥n de ayuda para pruebas manuales
async function quickTest() {
  log('üöÄ PRUEBA R√ÅPIDA DE API', 'cyan');
  log('======================', 'cyan');
  
  const connected = await testServerConnection();
  if (connected) {
    log('üéâ ¬°Servidor est√° funcionando correctamente!', 'green');
    log('üí° Ejecuta el test completo con: node test-coverages-api.js', 'cyan');
  }
}

// Ejecutar las pruebas si se llama directamente
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.includes('--quick') || args.includes('-q')) {
    quickTest()
      .then(() => process.exit(0))
      .catch(error => {
        log(`üí• Error: ${error.message}`, 'red');
        process.exit(1);
      });
  } else {
    runAPITestSuite()
      .then(() => {
        log('\n‚ú® Pruebas de API completadas', 'cyan');
        process.exit(0);
      })
      .catch(error => {
        log(`\nüí• Error fatal en API: ${error.message}`, 'red');
        process.exit(1);
      });
  }
}

module.exports = {
  runAPITestSuite,
  testServerConnection,
  testAutoDetectEndpoint,
  testGetCoveragesEndpoint,
  testUpdateGeographyEndpoint,
  quickTest
}; 