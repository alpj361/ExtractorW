const express = require('express');
const router = express.Router();
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { transcribeFile, transcribeImageWithGemini } = require('../services/transcription');
const { checkCreditsFunction, debitCreditsFunction } = require('../middlewares/credits');
const { verifyUserAccess } = require('../middlewares/auth');
const supabase = require('../utils/supabase');
const { GoogleGenerativeAI } = require('@google/generative-ai');

// Funci√≥n para generar descripci√≥n basada en transcripci√≥n
async function generateDescriptionFromTranscription(transcription, url = null) {
    try {
        if (!process.env.GEMINI_API_KEY) {
            console.warn('‚ùå GEMINI_API_KEY no configurada, saltando generaci√≥n de descripci√≥n');
            return null;
        }

        const genai = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
        const model = genai.getGenerativeModel({ model: 'gemini-2.5-flash' });

        const prompt = `Analiza la siguiente transcripci√≥n de un audio/video de X (Twitter) y genera una descripci√≥n concisa y √∫til.

TRANSCRIPCI√ìN:
"""
${transcription}
"""

INSTRUCCIONES:
1. Identifica el tema principal y los puntos clave mencionados
2. Describe el tipo de contenido (entrevista, opini√≥n, noticia, explicaci√≥n, etc.)
3. Menciona si hay datos importantes, nombres relevantes o informaci√≥n espec√≠fica
4. Mant√©n un tono profesional y objetivo
5. M√°ximo 150 caracteres para que sea √∫til como descripci√≥n

FORMATO DE RESPUESTA:
Solo devuelve la descripci√≥n en texto plano, sin JSON ni formateo adicional.

Ejemplos de buenas descripciones:
- "Entrevista sobre pol√≠ticas p√∫blicas con datos estad√≠sticos y propuestas espec√≠ficas"
- "Explicaci√≥n detallada del proceso electoral guatemalteco con ejemplos pr√°cticos"
- "An√°lisis pol√≠tico sobre declaraciones presidenciales con contexto hist√≥rico"

Genera una descripci√≥n similar basada en la transcripci√≥n proporcionada.`;

        console.log('ü§ñ Generando descripci√≥n con Gemini...');
        const result = await model.generateContent(prompt);
        const description = result.response.text().trim();
        
        console.log('‚úÖ Descripci√≥n generada:', description.substring(0, 100) + '...');
        return description;

    } catch (error) {
        console.error('‚ùå Error generando descripci√≥n:', error);
        return null;
    }
}

// Funci√≥n para detectar si una URL es multimedia (videos, im√°genes, etc.)
function isMediaUrl(url) {
    const mediaPatterns = [
        /twitter\.com\/\w+\/status\/\d+/,
        /x\.com\/\w+\/status\/\d+/,
        /youtube\.com\/watch\?v=/,
        /youtu\.be\//,
        /instagram\.com\/p\//,
        /tiktok\.com\/@[\w.]+\/video\/\d+/,
        /facebook\.com\/\w+\/videos\/\d+/,
        /vimeo\.com\/\d+/,
        /twitch\.tv\/videos\/\d+/,
        /\.(mp4|mov|avi|mkv|webm|m4v|mp3|wav|aac|ogg|flac|m4a|jpg|jpeg|png|gif|webp)$/i
    ];
    
    return mediaPatterns.some(pattern => pattern.test(url));
}

// Funci√≥n para descargar medios desde ExtractorT
async function downloadMediaFromUrl(url) {
    const candidateBaseUrls = [];

    const isProduction = process.env.NODE_ENV === 'production';

    // 1) URL expl√≠cita de entorno LOCAL (tiene prioridad absoluta si existe)
    if (process.env.EXTRACTORT_LOCAL_URL) {
        candidateBaseUrls.push(process.env.EXTRACTORT_LOCAL_URL);
    }

    // 2) Servicio interno docker-compose (ExtractorW y ExtractorT misma red)
    candidateBaseUrls.push('http://extractor_api:8000');

    // 3) Puerto publicado al host (cuando ExtractorT corre en Docker y ExtractorW fuera de Docker)
    candidateBaseUrls.push('http://localhost:8000');

    // 4) Gateway especial hacia el host desde un contenedor (ExtractorW dentro de Docker)
    candidateBaseUrls.push('http://host.docker.internal:8000');

    // 5) URL de producci√≥n (solo si estamos en producci√≥n o no hay otra opci√≥n)
    if (isProduction && process.env.EXTRACTORT_URL) {
        candidateBaseUrls.push(process.env.EXTRACTORT_URL);
    } else if (!isProduction && process.env.EXTRACTORT_URL) {
        // Colocar al final como √∫ltimo recurso
        candidateBaseUrls.push(process.env.EXTRACTORT_URL);
    }

    console.log('üîó URLs candidatas ExtractorT:', candidateBaseUrls.join(' | '));

    // Iterar sobre las URLs candidatas hasta que una funcione
    for (const baseUrl of candidateBaseUrls) {
        try {
            console.log(`üì• Descargando medios desde: ${url} v√≠a ${baseUrl}`);

            const response = await axios.post(`${baseUrl.replace(/\/$/, '')}/download_media`, {
                tweet_url: url,
                download_videos: true,
                download_images: true,
                quality: 'medium'
            }, {
                timeout: 60000,
                headers: { 'Content-Type': 'application/json' }
            });

            // Extraer campos relevantes considerando la nueva estructura { status, message, data }
            const { status, message: respMessage, data: respData } = response.data || {};
            const downloadedFiles = respData?.downloaded_files || respData?.files || response.data.downloaded_files || [];

            if (status === 'success') {
                if (downloadedFiles.length > 0) {
                    console.log(`‚úÖ Descarga exitosa (${downloadedFiles.length} archivos) usando ${baseUrl}`);
                } else {
                    console.warn(`‚ö†Ô∏è Descarga sin medios desde ${baseUrl} (solo texto del tweet)`);
                }
                return {
                    success: true,
                    files: downloadedFiles,
                    message: respMessage,
                    baseUrl,
                    tweet_text: respData?.tweet_text || null
                };
            }
        } catch (err) {
            console.warn(`‚ö†Ô∏è Fallo al intentar ${baseUrl}: ${err.message}`);
            // Contin√∫a con la siguiente URL candidata
        }
    }

    // Si llegamos aqu√≠ ninguna URL funcion√≥
    return {
        success: false,
        files: [],
        message: 'No se pudo descargar medios desde ninguna instancia de ExtractorT',
        tweet_text: null
    };
}

// Funci√≥n para procesar un archivo descargado
async function processDownloadedFile(filePath, fileName, userId, itemId) {
    try {
        console.log(`üîÑ Procesando archivo: ${fileName}`);
        
        // Verificar si el archivo existe
        if (!fs.existsSync(filePath)) {
            throw new Error(`Archivo no encontrado: ${filePath}`);
        }
        
        // Limpiar nombre de archivo (quitar query params y decodificar)
        let cleanName = fileName;
        try {
            cleanName = decodeURIComponent(fileName);
        } catch {}
        if (cleanName.includes('?')) {
            cleanName = cleanName.split('?')[0];
        }
        // Algunos nombres vienen con %3fname%3dsmall... ya decodificado lo anterior elimina parte posterior
        const fileExt = path.extname(cleanName).toLowerCase();
        const audioFormats = ['.mp3', '.wav', '.aac', '.ogg', '.flac', '.m4a'];
        const videoFormats = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.m4v'];
        const imageFormats = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
        
        if (audioFormats.includes(fileExt) || videoFormats.includes(fileExt)) {
            // Transcribir audio/video
            console.log(`üéµ Transcribiendo archivo de audio/video: ${fileName}`);
            const transcriptionResult = await transcribeFile(filePath, userId, {
                updateItemId: itemId, // Actualizar el item existente con la transcripci√≥n
                noAutoTags: true // No crear etiquetas autom√°ticamente
            });
            
            if (transcriptionResult.success === false) {
                console.warn('‚ö†Ô∏è Transcripci√≥n fallida, no se obtuvo audio. Se usar√° an√°lisis b√°sico.');
                return {
                    type: 'transcription_error',
                    result: `No se pudo transcribir audio del video ${fileName}. (${transcriptionResult.error})`,
                    metadata: transcriptionResult
                };
            }
            
            return {
                type: 'transcription',
                result: transcriptionResult.transcription,
                metadata: transcriptionResult.metadata
            };
            
        } else if (imageFormats.includes(fileExt)) {
            // Para im√°genes, generar transcripci√≥n/descripci√≥n usando Gemini Vision
            console.log(`üñºÔ∏è Generando transcripci√≥n de imagen v√≠a Gemini: ${fileName}`);
            try {
                const imgResult = await transcribeImageWithGemini(filePath, {
                    prompt: `Describe detalladamente el contenido de esta imagen de X (Twitter) en espa√±ol. Si la imagen contiene texto, transcr√≠belo exactamente como aparece.`
                });

                return {
                    type: 'image_transcription',
                    result: imgResult.transcription,
                    metadata: imgResult.metadata
                };
            } catch (visionError) {
                console.error('‚ùå Error en Gemini Vision, usando fallback b√°sico:', visionError.message);
                return {
                    type: 'image_analysis',
                    result: `Imagen descargada: ${fileName}. No se pudo generar transcripci√≥n autom√°tica.`,
                    metadata: {
                        fileName: fileName,
                        fileType: fileExt.substring(1).toUpperCase(),
                        timestamp: new Date().toISOString(),
                        error: visionError.message
                    }
                };
            }
        } else {
            // Archivo no compatible
            throw new Error(`Formato de archivo no compatible: ${fileExt}`);
        }
        
    } catch (error) {
        console.error(`‚ùå Error procesando archivo: ${error.message}`);
        throw error;
    }
}

// Endpoint para analizar enlaces multimedia (ya no requiere etiqueta "pendiente-analisis")
router.post('/analyze-pending-links', verifyUserAccess, async (req, res) => {
    try {
        const userId = req.user.id;
        const { 
            itemIds = null, // IDs espec√≠ficos a procesar (opcional)
            processAll = false, // Si procesar enlaces recientes (√∫ltimos 30 d√≠as)
            dryRun = false, // Solo simular, no realizar cambios
            shouldGenerateDescription = false // Si generar descripci√≥n con IA despu√©s de transcripci√≥n
        } = req.body;
        
        console.log(`üîç Iniciando an√°lisis de enlaces multimedia para usuario: ${userId}`);
        console.log(`ü§ñ Generar descripci√≥n con IA: ${shouldGenerateDescription}`);
        
        // Obtener enlaces para procesar - usar consulta m√°s simple para evitar problemas
        console.log(`üìä Construyendo consulta para obtener enlaces para procesar...`);
        console.log(`üë§ User ID: ${userId}`);
        
        let pendingItems, fetchError;
        
        try {
            // Primero intentar consulta simplificada si hay IDs espec√≠ficos
            if (itemIds && itemIds.length > 0) {
                console.log(`üéØ Filtrando por IDs espec√≠ficos: ${itemIds.join(', ')}`);
                console.log(`üîÑ Ejecutando consulta espec√≠fica a Supabase...`);
                
                const { data, error } = await supabase
                    .from('codex_items')
                    .select('*')
                    .eq('user_id', userId)
                    .in('id', itemIds);
                
                // Aceptar tanto el esquema antiguo (tipo = 'enlace') como el nuevo (tipo = 'item' + original_type = 'link')
                pendingItems = (data || []).filter((i) => i && (i.tipo === 'enlace' || (i.tipo === 'item' && (i.original_type === 'link' || i.original_type === 'enlace'))));
                fetchError = error;
                
                console.log(`‚úÖ Consulta espec√≠fica completada. Encontrados ${pendingItems?.length || 0} elementos`);
                
                // Ya no filtramos por etiqueta "pendiente-analisis" ya que se elimin√≥ del sistema
                // Procesamos directamente los enlaces especificados por ID
                console.log(`‚úÖ Enlaces espec√≠ficos para procesar: ${pendingItems?.length || 0}`);
            } else {
                // Consulta general para todos los enlaces del usuario
                console.log(`üîÑ Ejecutando consulta general a Supabase...`);
                
                const { data, error } = await supabase
                    .from('codex_items')
                    .select('*')
                    .eq('user_id', userId)
                    .in('tipo', ['enlace', 'item']);
                
                // Filtrar por tipos soportados
                pendingItems = (data || []).filter((i) => i && (i.tipo === 'enlace' || (i.tipo === 'item' && (i.original_type === 'link' || i.original_type === 'enlace'))));
                fetchError = error;
                
                console.log(`‚úÖ Consulta general completada. Encontrados ${pendingItems?.length || 0} enlaces totales`);
                
                // Para consulta general, filtramos enlaces recientes (√∫ltimos 30 d√≠as) para evitar procesar demasiados
                if (pendingItems && !fetchError) {
                    const thirtyDaysAgo = new Date();
                    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                    
                    pendingItems = pendingItems.filter(item => {
                        const itemDate = new Date(item.created_at);
                        return itemDate >= thirtyDaysAgo;
                    });
                    console.log(`üìÖ Filtrados por fecha (√∫ltimos 30 d√≠as): ${pendingItems.length} enlaces recientes`);
                }
            }
        } catch (queryError) {
            console.error(`‚ùå Error en consulta a Supabase:`, queryError);
            fetchError = queryError;
            pendingItems = null;
        }
        
        console.log(`üîç Verificando errores de consulta...`);
        if (fetchError) {
            console.error('‚ùå Error obteniendo elementos pendientes:', fetchError);
            return res.status(500).json({
                success: false,
                message: 'Error al obtener elementos pendientes',
                error: fetchError.message
            });
        }
        
        console.log(`üìä Verificando resultados de consulta...`);
        if (!pendingItems || pendingItems.length === 0) {
            console.log(`‚ÑπÔ∏è No se encontraron enlaces para procesar`);
            return res.json({
                success: true,
                message: 'No hay enlaces para procesar (sin IDs espec√≠ficos o sin enlaces recientes)',
                processed: 0,
                results: []
            });
        }
        
        console.log(`üìã Encontrados ${pendingItems.length} enlaces para procesar`);
        console.log(`üîÑ Iniciando procesamiento de enlaces...`);
        
        const results = [];
        let processedCount = 0;
        let totalCreditsUsed = 0;
        
        console.log(`üéØ Iniciando bucle de procesamiento para ${pendingItems.length} elementos...`);
        
        for (let index = 0; index < pendingItems.length; index++) {
            const item = pendingItems[index];
            try {
                console.log(`\nüîÑ Procesando item ${index + 1}/${pendingItems.length}: ${item.id} - ${item.titulo}`);
                
                // Compatibilidad con nuevo modelo: usar source_url cuando url est√© vac√≠o
                const url = item.url || item.source_url;
                if (!url) {
                    console.log(`‚ö†Ô∏è Item sin URL: ${item.id}`);
                    results.push({
                        itemId: item.id,
                        success: false,
                        message: 'Item sin URL',
                        creditsUsed: 0
                    });
                    continue;
                }
                
                console.log(`üîó URL del item: ${url}`);
                
                // Verificar si es URL multimedia
                console.log(`üîç Verificando si es URL multimedia...`);
                const isMultimedia = isMediaUrl(url);
                console.log(`üì± Es multimedia: ${isMultimedia}`);
                
                if (!isMultimedia) {
                    console.log(`‚ö†Ô∏è URL no es multimedia: ${url}`);
                    
                    // Procesar como enlace b√°sico (menos cr√©ditos)
                    const basicAnalysis = `Enlace analizado: ${url}. T√≠tulo: ${item.titulo}. Descripci√≥n: ${item.descripcion || 'Sin descripci√≥n'}.`;
                    
                    if (!dryRun) {
                        // Verificar cr√©ditos (5 cr√©ditos para an√°lisis b√°sico)
                        const creditsCheck = await checkCreditsFunction(userId, 5);
                        if (!creditsCheck.hasCredits) {
                            results.push({
                                itemId: item.id,
                                success: false,
                                message: 'Cr√©ditos insuficientes para an√°lisis b√°sico',
                                creditsUsed: 0
                            });
                            continue;
                        }
                        
                        // Actualizar item con an√°lisis b√°sico
                        const { error: updateError } = await supabase
                            .from('codex_items')
                            .update({
                                descripcion: item.descripcion ? `${item.descripcion}\n\n[AN√ÅLISIS B√ÅSICO]\n${basicAnalysis}` : basicAnalysis
                            })
                            .eq('id', item.id);
                        
                        if (updateError) {
                            throw updateError;
                        }
                        
                        // No debitar cr√©ditos si es admin
                        const adminCheck = await checkCreditsFunction(userId, 0);
                        const creditsToDebit = adminCheck.isAdmin ? 0 : 5;
                        if (creditsToDebit > 0) {
                            await debitCreditsFunction(userId, creditsToDebit, 'basic_link_analysis', { itemId: item.id, url });
                            totalCreditsUsed += creditsToDebit;
                        }
                    }
                    
                    results.push({
                        itemId: item.id,
                        success: true,
                        message: 'An√°lisis b√°sico completado',
                        creditsUsed: 5,
                        analysisType: 'basic'
                    });
                    
                    processedCount++;
                    continue;
                }
                
                // Es URL multimedia, procesar descarga
                console.log(`üì± URL multimedia detectada: ${url}`);
                
                if (!dryRun) {
                    console.log(`üí∞ Verificando cr√©ditos para an√°lisis multimedia...`);
                    // Verificar cr√©ditos (5 cr√©ditos para multimedia)
                    const creditsCheck = await checkCreditsFunction(userId, 5);
                    console.log(`üí∞ Resultado verificaci√≥n cr√©ditos: ${creditsCheck.hasCredits}`);
                    if (!creditsCheck.hasCredits) {
                        console.log(`‚ùå Cr√©ditos insuficientes para ${item.id}`);
                        results.push({
                            itemId: item.id,
                            success: false,
                            message: 'Cr√©ditos insuficientes para an√°lisis multimedia',
                            creditsUsed: 0
                        });
                        continue;
                    }
                    console.log(`‚úÖ Cr√©ditos verificados correctamente`);
                }
                
                // Descargar medios con timeout
                console.log(`üì• Iniciando descarga de medios para: ${url}`);
                
                let downloadResult;
                try {
                    // Crear timeout para descarga (m√°ximo 45 segundos)
                    const downloadPromise = downloadMediaFromUrl(url);
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout: La descarga tard√≥ m√°s de 45 segundos')), 45000);
                    });
                    
                    downloadResult = await Promise.race([downloadPromise, timeoutPromise]);
                    console.log(`üì• Resultado de descarga:`, downloadResult.success ? '√âXITO' : 'FALLO');
                } catch (downloadTimeout) {
                    console.error(`‚è∞ Timeout en descarga de medios: ${downloadTimeout.message}`);
                    downloadResult = {
                        success: false,
                        files: [],
                        message: `Timeout en descarga: ${downloadTimeout.message}`,
                        tweet_text: null
                    };
                }
                
                if (!downloadResult.success) {
                    console.log(`‚ùå Fall√≥ descarga: ${downloadResult.message}`);
                    
                    // Continuar con an√°lisis b√°sico si falla la descarga
                    const basicAnalysis = `Enlace multimedia procesado: ${url}. Descarga fall√≥: ${downloadResult.message}. An√°lisis b√°sico realizado.`;
                    
                    if (!dryRun) {
                        // Verificar cr√©ditos para an√°lisis b√°sico
                        const creditsCheck = await checkCreditsFunction(userId, 5);
                        if (!creditsCheck.hasCredits) {
                            results.push({
                                itemId: item.id,
                                success: false,
                                message: 'Cr√©ditos insuficientes para an√°lisis b√°sico',
                                creditsUsed: 0
                            });
                            continue;
                        }
                        
                        // Actualizar con an√°lisis b√°sico
                        const { error: updateError } = await supabase
                            .from('codex_items')
                            .update({
                                descripcion: item.descripcion ? `${item.descripcion}\n\n[AN√ÅLISIS B√ÅSICO]\n${basicAnalysis}` : basicAnalysis
                            })
                            .eq('id', item.id);
                        
                        if (updateError) {
                            throw updateError;
                        }
                        
                        // No debitar cr√©ditos si es admin
                        const adminCheck = await checkCreditsFunction(userId, 0);
                        const creditsToDebit = adminCheck.isAdmin ? 0 : 5;
                        if (creditsToDebit > 0) {
                            await debitCreditsFunction(userId, creditsToDebit, 'basic_link_analysis', { itemId: item.id, url });
                            totalCreditsUsed += creditsToDebit;
                        }
                    }
                    
                    results.push({
                        itemId: item.id,
                        success: true,
                        message: 'An√°lisis b√°sico completado (descarga fall√≥)',
                        creditsUsed: 5,
                        analysisType: 'basic_fallback'
                    });
                    
                    processedCount++;
                    continue;
                }
                
                // Procesar archivos descargados
                let finalAnalysis = '';
                const tempFilesToCleanup = [];
                const usedBaseUrl = downloadResult.baseUrl || candidateBaseUrls.find(u=>u);

                // NUEVO: Obtener tweet_text de la respuesta de descarga
                const tweetText = downloadResult.tweet_text || null;
                let combinedTranscription = null;

                for (const file of downloadResult.files) {
                    try {
                        let effectivePath = file.path || file.filepath;
                        if (!effectivePath || !fs.existsSync(effectivePath)) {
                            // Construir URL del endpoint /media/ en ExtractorT
                            let remoteFileUrl = file.url;
                            
                            // Si la URL es relativa (/media/filename), construir URL completa
                            if (remoteFileUrl && remoteFileUrl.startsWith('/media/')) {
                                remoteFileUrl = `${usedBaseUrl.replace(/\/$/, '')}${remoteFileUrl}`;
                            } else if (!remoteFileUrl && usedBaseUrl) {
                                // Fallback: construir URL usando filename
                                remoteFileUrl = `${usedBaseUrl.replace(/\/$/, '')}/media/${encodeURIComponent(file.filename)}`;
                            }
                            
                            if (!remoteFileUrl) {
                                throw new Error('Ruta de archivo inaccesible y no se pudo construir URL remota');
                            }

                            const tempDir = '/tmp';
                            let rawName = file.filename || path.basename(remoteFileUrl);
                            try { rawName = decodeURIComponent(rawName);} catch {}
                            if (rawName.includes('?')) {
                                rawName = rawName.split('?')[0];
                            }
                            const localFilename = `${Date.now()}_${rawName}`;
                            effectivePath = path.join(tempDir, localFilename);

                            console.log(`‚¨áÔ∏è Descargando archivo faltante desde ${remoteFileUrl} a ${effectivePath}`);
                            const writer = fs.createWriteStream(effectivePath);
                            const resp = await axios.get(remoteFileUrl, { responseType: 'stream', timeout: 60000 });
                            await new Promise((resolve, reject) => {
                                resp.data.pipe(writer);
                                let error = null;
                                writer.on('error', err => {
                                    error = err;
                                    writer.close();
                                    reject(err);
                                });
                                writer.on('close', () => {
                                    if (!error) resolve();
                                });
                            });
                            console.log(`‚úÖ Archivo descargado localmente (${(fs.statSync(effectivePath).size/1024/1024).toFixed(2)} MB)`);
                        }

                        const filePath = effectivePath;
                        const fileName = file.filename;
                        tempFilesToCleanup.push(filePath);
                        
                        const processResult = await processDownloadedFile(filePath, fileName, userId, item.id);
                        
                        if (processResult.type === 'transcription') {
                            // Combinar tweet_text con la transcripci√≥n si est√° disponible
                            if (tweetText && processResult.result) {
                                combinedTranscription = `${tweetText}\n-----\n${processResult.result}`;
                            } else {
                                combinedTranscription = processResult.result;
                            }
                            // Si est√° habilitada la generaci√≥n de descripci√≥n, generar descripci√≥n basada en la combinaci√≥n
                            if (shouldGenerateDescription && !dryRun) {
                                console.log('ü§ñ Generando descripci√≥n basada en tweet_text + transcripci√≥n...');
                                const aiDescription = await generateDescriptionFromTranscription(combinedTranscription, item.url);
                                if (aiDescription) {
                                    try {
                                        const { error: descUpdateError } = await supabase
                                            .from('codex_items')
                                            .update({ descripcion: aiDescription })
                                            .eq('id', item.id);
                                        if (descUpdateError) {
                                            console.error('‚ùå Error actualizando descripci√≥n del item:', descUpdateError);
                                        } else {
                                            console.log('‚úÖ Descripci√≥n del item actualizada con IA (solo resumen)');
                                        }
                                    } catch (descError) {
                                        console.error('‚ùå Error en actualizaci√≥n de descripci√≥n:', descError);
                                    }
                                } else {
                                    console.log('‚ö†Ô∏è No se pudo generar descripci√≥n IA');
                                }
                            }
                            // Guardar el texto combinado en analisis_detallado
                            finalAnalysis += `\n\n[TRANSCRIPCI√ìN - ${fileName}]\n${combinedTranscription}`;
                        } else if (processResult.type === 'image_transcription') {
                            // Generar combinaci√≥n con tweetText si existe
                            if (tweetText && processResult.result) {
                                combinedTranscription = `${tweetText}\n-----\n${processResult.result}`;
                            } else {
                                combinedTranscription = processResult.result;
                            }

                            // Guardar descripci√≥n IA si aplica
                            if (shouldGenerateDescription && !dryRun) {
                                try {
                                    console.log('ü§ñ Generando descripci√≥n basada en tweet_text + transcripci√≥n de imagen...');
                                    const aiDescription = await generateDescriptionFromTranscription(combinedTranscription, item.url);
                                    if (aiDescription) {
                                        const { error: descUpdateError } = await supabase
                                            .from('codex_items')
                                            .update({ descripcion: aiDescription })
                                            .eq('id', item.id);
                                        if (descUpdateError) {
                                            console.error('‚ùå Error actualizando descripci√≥n del item:', descUpdateError);
                                        }
                                    }
                                } catch(e){ console.error('‚ùå Error generando descripci√≥n IA:', e);} 
                            }

                            finalAnalysis += `\n\n[TRANSCRIPCI√ìN IMAGEN - ${fileName}]\n${processResult.result}`;
                        } else if (processResult.type === 'image_analysis') {
                            finalAnalysis += `\n\n[AN√ÅLISIS DE IMAGEN - ${fileName}]\n${processResult.result}`;
                        } else if (processResult.type === 'transcription_error') {
                            finalAnalysis += `\n\n[ERROR TRANSCRIPCI√ìN - ${fileName}]\n${processResult.result}`;
                        }
                        
                    } catch (procError) {
                        console.error(`‚ùå Error procesando ${file.filename}:`, procError);
                        finalAnalysis += `\n\n[ERROR - ${file.filename}]\nError procesando archivo: ${procError.message}`;
                    }
                }
                
                // Limpiar archivos temporales
                for (const tempFile of tempFilesToCleanup) {
                    try {
                        if (fs.existsSync(tempFile)) {
                            fs.unlinkSync(tempFile);
                            console.log(`‚úÖ Archivo eliminado temporalmente: ${tempFile}`);
                        }
                    } catch (cleanupError) {
                        console.error(`‚ùå Error al intentar eliminar archivo temporal: ${cleanupError.message}`);
                    }
                }
                
                // Actualizar item con an√°lisis final
                await supabase
                    .from('codex_items')
                    .update({ analisis_detallado: finalAnalysis })
                    .eq('id', item.id);
                
                // NUEVO: Actualizar tambi√©n el campo transcripcion con el texto combinado
                if (combinedTranscription) {
                    console.log('üü¢ Guardando en transcripcion:', combinedTranscription);
                    await supabase
                        .from('codex_items')
                        .update({ transcripcion: combinedTranscription })
                        .eq('id', item.id);
                    const { data: txAfter, error: txErr } = await supabase
                        .from('codex_items')
                        .select('transcripcion, audio_transcription')
                        .eq('id', item.id);
                    if (txErr) {
                        console.error('‚ùå Error verificando transcripci√≥n despu√©s del update:', txErr);
                    } else {
                        console.log('üü¢ Valor en supabase despu√©s de update (transcripcion):', txAfter && txAfter[0] && txAfter[0].transcripcion);
                        console.log('üü¢ Valor en supabase despu√©s de update (audio_transcription):', txAfter && txAfter[0] && txAfter[0].audio_transcription);
                    }
                }
                
                // --- NUEVO: Manejar tweets sin media descargada ---
                if (downloadResult.files.length === 0 && tweetText) {
                    console.log('üìù Tweet sin media: usando tweet.text como transcripci√≥n');
                    combinedTranscription = tweetText;

                    // Generar descripci√≥n IA si corresponde
                    if (shouldGenerateDescription && !dryRun) {
                        try {
                            console.log('ü§ñ Generando descripci√≥n basada en tweet_text (sin media)...');
                            const aiDescription = await generateDescriptionFromTranscription(combinedTranscription, item.url);
                            if (aiDescription) {
                                const { error: descUpdateError } = await supabase
                                    .from('codex_items')
                                    .update({ descripcion: aiDescription })
                                    .eq('id', item.id);
                                if (descUpdateError) {
                                    console.error('‚ùå Error actualizando descripci√≥n del item:', descUpdateError);
                                } else {
                                    console.log('‚úÖ Descripci√≥n del item actualizada con IA (solo tweet texto)');
                                }
                            }
                        } catch (tweetDescErr) {
                            console.error('‚ùå Error generando descripci√≥n IA para tweet sin media:', tweetDescErr);
                        }
                    }

                    finalAnalysis += `\n\n[TRANSCRIPCI√ìN - TWEET]\n${tweetText}`;

                    // Actualizar campos de transcripci√≥n directamente
                    try {
                        await supabase
                            .from('codex_items')
                            .update({
                                transcripcion: combinedTranscription,
                                audio_transcription: combinedTranscription
                            })
                            .eq('id', item.id);
                        console.log('‚úÖ Campos transcripcion y audio_transcription actualizados con tweet_text');
                    } catch (txUpdateErr) {
                        console.error('‚ùå Error actualizando campos de transcripci√≥n:', txUpdateErr);
                    }
                }
                
                // No debitar cr√©ditos si es admin
                const adminCheck = await checkCreditsFunction(userId, 0);
                // Costo fijo de 5 cr√©ditos para an√°lisis multimedia (igual que b√°sico)
                let calculatedCost = 5;
                const creditsToDebit = adminCheck.isAdmin ? 0 : calculatedCost;
                if (creditsToDebit > 0) {
                    await debitCreditsFunction(userId, creditsToDebit, 'final_link_analysis', { itemId: item.id, url });
                    totalCreditsUsed += creditsToDebit;
                }
                
                results.push({
                    itemId: item.id,
                    success: true,
                    message: 'An√°lisis final completado',
                    creditsUsed: creditsToDebit,
                    analysisType: 'final',
                    tweetData: {
                        source: url,
                        text: tweetText,
                        timestamp: new Date().toISOString(),
                        media_url: downloadResult.files && downloadResult.files.length > 0 ? (downloadResult.files[0].url || null) : null,
                        type: downloadResult.files && downloadResult.files.length > 0 ? (/\.(jpg|jpeg|png|gif|webp)$/i.test(downloadResult.files[0].filename || '') ? 'image' : 'other') : 'text',
                        transcription: combinedTranscription
                    }
                });
                
                processedCount++;
                console.log(`‚úÖ Item ${index + 1}/${pendingItems.length} completado exitosamente`);
                
            } catch (error) {
                console.error(`‚ùå Error procesando item ${index + 1}/${pendingItems.length}: ${item.id} - ${item.titulo}:`, error);
                results.push({
                    itemId: item.id,
                    success: false,
                    message: error.message,
                    creditsUsed: 0
                });
                processedCount++;
                console.log(`üí• Item ${index + 1}/${pendingItems.length} completado con error`);
            }
            
            console.log(`üìä Progreso: ${index + 1}/${pendingItems.length} procesados hasta ahora`);
        }
        
        console.log(`üéâ Bucle de procesamiento completado. Total procesados: ${processedCount}`);
        console.log(`üí∞ Total cr√©ditos usados: ${totalCreditsUsed}`);
        
        return res.json({
            success: true,
            message: 'An√°lisis de enlaces pendientes completado',
            processed: processedCount,
            totalCreditsUsed: totalCreditsUsed,
            results: results
        });
    } catch (error) {
        console.error('‚ùå Error al procesar an√°lisis de enlaces pendientes:', error);
        return res.status(500).json({
            success: false,
            message: 'Error al procesar an√°lisis de enlaces pendientes',
            error: error.message
        });
    }
});

module.exports = router;

// Exportar funci√≥n para pruebas
module.exports.generateDescriptionFromTranscription = generateDescriptionFromTranscription;