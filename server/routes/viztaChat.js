const express = require('express');
const router = express.Router();
const { verifyUserAccess } = require('../middlewares/auth');
const mcpService = require('../services/mcp');
const recentScrapesService = require('../services/recentScrapes');
const memoriesService = require('../services/memories');
const agentesService = require('../services/agentesService');
const supabase = require('../utils/supabase');

// ===================================================================
// VIZTA CHAT ROUTES
// Endpoints para el chat inteligente con integraci√≥n MCP
// ===================================================================

/**
 * Post-procesa respuestas del chat para asegurar formato consistente
 */
function formatChatResponse(response, toolResult = null) {
  try {
    // Limpiar respuesta muy larga
    if (response.length > 2000) {
      console.log('‚ö†Ô∏è Respuesta muy larga, truncando...');
      response = response.substring(0, 1800) + '\n\n*[Respuesta truncada para mejor legibilidad]*';
    }

    // Asegurar que tenga formato markdown b√°sico si no lo tiene
    if (!response.includes('##') && !response.includes('###')) {
      const lines = response.split('\n').filter(line => line.trim());
      
      if (lines.length > 0) {
        let formatted = `## üìä An√°lisis\n\n`;
        formatted += lines.join('\n\n');
        
        // Agregar resumen de datos si disponible
        if (toolResult && toolResult.tweets_found) {
          formatted += `\n\n### üìä Datos analizados:\n‚Ä¢ ${toolResult.tweets_found} tweets encontrados`;
          if (toolResult.analysis_metadata?.sentiment_distribution) {
            const sentiments = Object.entries(toolResult.analysis_metadata.sentiment_distribution);
            if (sentiments.length > 0) {
              formatted += `\n‚Ä¢ Sentimientos: ${sentiments.map(([s, c]) => `${s} (${c})`).join(', ')}`;
            }
          }
        }
        
        response = formatted;
      }
    }

    // Limpiar texto muy corrido (sin espacios entre p√°rrafos)
    response = response
      .replace(/\n{3,}/g, '\n\n') // M√°ximo 2 saltos de l√≠nea consecutivos
      .replace(/(\w)(\n)(### |## |\*\*)/g, '$1\n\n$3') // Espacios antes de headers
      .replace(/(\w)(\n)(‚Ä¢ )/g, '$1\n\n$3') // Espacios antes de bullets
      .trim();

    // Asegurar que los emojis tengan espacio despu√©s
    response = response.replace(/([üìäüìàüí≠‚ö°üéØüîç])([A-Za-z])/g, '$1 $2');

    return response;

  } catch (error) {
    console.error('‚ùå Error formateando respuesta:', error);
    return response; // Devolver original si hay error
  }
}

// Cargar dependencias de forma condicional
let OpenAI, openai, uuidv4;

try {
  OpenAI = require('openai');
  const { v4 } = require('uuid');
  uuidv4 = v4;
  
  // Configurar OpenAI
  openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });
  
  console.log('‚úÖ Dependencias de Vizta Chat cargadas correctamente');
} catch (error) {
  console.warn('‚ö†Ô∏è Dependencias de Vizta Chat no disponibles:', error.message);
  console.warn('üì¶ Instala las dependencias con: npm install openai uuid');
}

/**
 * POST /api/vizta-chat/query
 * Endpoint principal para consultas de Vizta Chat
 */
router.post('/query', verifyUserAccess, async (req, res) => {
  try {
    // Verificar que las dependencias est√©n disponibles
    if (!openai || !uuidv4) {
      // Fallback temporal sin OpenAI
      console.log('‚ö†Ô∏è Usando fallback sin OpenAI para Vizta Chat');
      
      const fallbackSessionId = sessionId || `fallback_${Date.now()}`;
      
      // Usar directamente nitter_context como herramienta por defecto
      try {
        const toolResult = await mcpService.executeTool('nitter_context', {
          q: message,
          location: 'guatemala',
          limit: 5
        }, req.user);
        
        if (toolResult.success && toolResult.tweets) {
          // Guardar en recent_scrapes
          await recentScrapesService.saveScrape({
            queryOriginal: message,
            queryClean: message,
            herramienta: 'nitter_context',
            categoria: 'General',
            tweets: toolResult.tweets,
            userId: userId,
            sessionId: fallbackSessionId,
            mcpRequestId: `fallback_${Date.now()}`,
            mcpExecutionTime: 0,
            location: 'guatemala'
          });
          
          return res.json({
            success: true,
            response: `He encontrado ${toolResult.tweets.length} tweets relacionados con "${message}". Los datos han sido guardados y est√°n disponibles para an√°lisis.`,
            toolUsed: 'nitter_context',
            toolArgs: { q: message, location: 'guatemala', limit: 5 },
            toolResult: toolResult,
            sessionId: fallbackSessionId,
            requestId: `fallback_${Date.now()}`,
            executionTime: 0,
            timestamp: new Date().toISOString(),
            mode: 'fallback'
          });
        } else {
          throw new Error('No se pudieron obtener tweets');
        }
      } catch (error) {
        return res.status(500).json({
          success: false,
          message: 'Error en modo fallback: ' + error.message,
          error: 'Instala las dependencias con: npm run install-vizta'
        });
      }
    }

    const { message, sessionId } = req.body;
    const userId = req.user.id;
    
    if (!message) {
      return res.status(400).json({
        success: false,
        message: 'El mensaje es requerido'
      });
    }

    console.log(`ü§ñ Nueva consulta Vizta Chat de usuario ${userId}: "${message}"`);

    // Generar IDs √∫nicos
    const requestId = uuidv4();
    const chatSessionId = sessionId || uuidv4();

    // 1. Guardar mensaje del usuario en memories
    await memoriesService.saveMessage({
      sessionId: chatSessionId,
      userId: userId,
      role: 'user',
      content: message,
      messageType: 'message',
      modelUsed: 'gpt-4o-mini',
      metadata: { requestId: requestId }
    });

    // 2. Obtener los √∫ltimos 10 mensajes de la conversaci√≥n para contexto
    const conversationHistory = await memoriesService.getSessionMessages(chatSessionId, 10);
    const previousMessages = memoriesService.formatMessagesForOpenAI(conversationHistory);

    // Obtener herramientas disponibles del MCP
    const availableTools = await mcpService.listAvailableTools();
    
    // Preparar funciones para GPT-4o mini
    const functions = availableTools.map(tool => {
      // Transformar par√°metros del formato MCP al formato OpenAI
      const properties = {};
      const required = [];
      
      Object.keys(tool.parameters).forEach(key => {
        const param = tool.parameters[key];
        properties[key] = {
          type: param.type,
          description: param.description
        };
        
        // Agregar constrains adicionales si existen
        if (param.min !== undefined) properties[key].minimum = param.min;
        if (param.max !== undefined) properties[key].maximum = param.max;
        if (param.default !== undefined) properties[key].default = param.default;
        
        // Para arrays, agregar definici√≥n de items
        if (param.type === 'array' && param.items) {
          properties[key].items = param.items;
        }
        
        // Agregar a required si es necesario
        if (param.required === true) {
          required.push(key);
        }
      });
      
      return {
        name: tool.name,
        description: tool.description,
        parameters: {
          type: 'object',
          properties: properties,
          required: required
        }
      };
    });

    // Agregar funci√≥n especial para crear planes de ejecuci√≥n multi-step
    functions.push({
      name: 'create_execution_plan',
      description: 'Crear un plan de ejecuci√≥n multi-step para consultas complejas que requieren m√∫ltiples herramientas en secuencia',
      parameters: {
        type: 'object',
        properties: {
          steps: {
            type: 'array',
            description: 'Array de pasos a ejecutar en orden',
            items: {
              type: 'object',
              properties: {
                step_number: {
                  type: 'number',
                  description: 'N√∫mero de paso (1, 2, 3, etc.)'
                },
                tool: {
                  type: 'string',
                  description: 'Nombre de la herramienta a usar'
                },
                args: {
                  type: 'object',
                  description: 'Argumentos para la herramienta'
                },
                description: {
                  type: 'string',
                  description: 'Descripci√≥n de qu√© hace este paso'
                },
                depends_on_previous: {
                  type: 'boolean',
                  description: 'Si este paso depende del resultado del paso anterior'
                }
              },
              required: ['step_number', 'tool', 'args', 'description']
            }
          },
          final_goal: {
            type: 'string',
            description: 'Objetivo final del plan de ejecuci√≥n'
          }
        },
        required: ['steps', 'final_goal']
      }
    });

    console.log('üîç Esquema de funciones para OpenAI:', JSON.stringify(functions, null, 2));

    // 3. NUEVA ORQUESTACI√ìN CON SISTEMA DE AGENTES
    // Vizta delega trabajo a Laura (monitoreo) y Robert (documentos)
    console.log('üéØ Iniciando orquestaci√≥n de agentes para consulta...');
    
    const startTime = Date.now();
    const agentResults = await agentesService.orchestrateQuery(message, req.user, {
      sessionId: chatSessionId,
      previousMessages: previousMessages
    });
    const orchestrationTime = Date.now() - startTime;

    console.log(`ü§ñ Orquestaci√≥n completada en ${orchestrationTime}ms:`, {
      laura_tasks: agentResults.laura_findings.length,
      robert_tasks: agentResults.robert_findings.length,
      total_execution_time: agentResults.total_execution_time
    });

    // Preparar datos consolidados para guardar en recent_scrapes
    const allTweets = agentResults.laura_findings
      .filter(finding => finding.findings?.top_posts)
      .flatMap(finding => finding.findings.top_posts);

    if (allTweets.length > 0) {
      await recentScrapesService.saveScrape({
        queryOriginal: message,
        queryClean: message,
        herramienta: 'agentes_colaborativos',
        categoria: 'An√°lisis Integral',
        tweets: allTweets,
        userId: userId,
        sessionId: chatSessionId,
        mcpRequestId: requestId,
        mcpExecutionTime: agentResults.total_execution_time,
        location: 'guatemala',
        metadata: {
          laura_findings: agentResults.laura_findings.length,
          robert_findings: agentResults.robert_findings.length,
          orchestration_time: orchestrationTime
        }
      });
    }

    // Preparar mensajes incluyendo historial de conversaci√≥n
    // Obtener fecha actual para contexto temporal
    const now = new Date();
    const currentDate = now.toLocaleDateString('es-ES', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
    const currentYear = now.getFullYear();
    const currentMonth = now.toLocaleString('es-ES', { month: 'long' });
    
    const systemMessage = {
      role: 'system',
      content: `Eres Vizta, el orquestador principal de un sistema de agentes inteligentes para an√°lisis social en Guatemala.

**FECHA ACTUAL: ${currentDate}**
**CONTEXTO TEMPORAL: ${currentMonth} ${currentYear}**

**TU NUEVO ROL COMO ORQUESTADOR:**
‚Ä¢ Recibes datos PRE-PROCESADOS de tus agentes especializados Laura (monitoreo) y Robert (documentos)
‚Ä¢ Tu trabajo es SINTETIZAR, ANALIZAR y PRESENTAR estos hallazgos de forma clara y accionable
‚Ä¢ NO ejecutes herramientas directamente - tus agentes ya trabajaron por ti
‚Ä¢ NO prometas "buscar", "analizar" o "investigar" - ¬°YA SE HIZO! Presenta los resultados

**AGENTES QUE TRABAJARON PARA TI:**
üîç **Laura** (Analista de Monitoreo): Vigilancia de redes sociales, tendencias, sentimientos
üìö **Robert** (Orquestador Interno): Gesti√≥n de proyectos y documentos del usuario

**RESULTADOS DE LA INVESTIGACI√ìN COMPLETADA:**
${JSON.stringify(agentResults, null, 2)}

**INSTRUCCIONES CR√çTICAS:**
- NUNCA digas "voy a buscar", "proceder√© a analizar" o "un momento por favor"
- SIEMPRE comienza con los resultados encontrados: "He analizado...", "Los datos muestran...", "Seg√∫n la investigaci√≥n realizada..."
- Si no hay datos (0 tweets), explica qu√© se busc√≥ y sugiere t√©rminos alternativos
- Enf√≥cate en presentar y analizar los hallazgos existentes, no en promesas de futuras b√∫squedas

**TU TRABAJO AHORA:**
- Enf√≥cate en informaci√≥n ACTUAL y RECIENTE (${currentMonth} ${currentYear})
- Filtra informaci√≥n obsoleta o de fechas anteriores
- Contextualiza todo en el tiempo presente
- Busca eventos, noticias y tendencias de AHORA 

--------------------------------------------------------------------
**MEMORIA CONVERSACIONAL AVANZADA**
‚Ä¢ Usa los mensajes previos del usuario (memories) para evitar repetir b√∫squedas.
‚Ä¢ Referencia insights o resultados anteriores cuando aporten valor.
‚Ä¢ Si existen hallazgos relevantes en la sesi√≥n, enl√°zalos brevemente antes de ejecutar nuevas herramientas.

**PROCESAMIENTO INTELIGENTE DE RESULTADOS**
Siempre que recibas datos de una herramienta sigue este flujo:
1. **Analiza**‚ÄÇ¬øqu√© significan los datos?
2. **Contextualiza**‚ÄÇ¬øc√≥mo se relacionan con Guatemala y el momento actual?
3. **Sintetiza**‚ÄÇpatrones o tendencias detectadas.
4. **Proyecta**‚ÄÇimplicaciones futuras o posibles escenarios.
5. **Recomienda**‚ÄÇacciones concretas o pr√≥ximos pasos.

**FORMATO ADAPTATIVO DE RESPUESTA**
Detecta la intenci√≥n del usuario y responde con la estructura m√°s apropiada:
    ‚Ä¢ *An√°lisis profundo* ‚Üí Executive Summary ‚ñ∏ Detalles ‚ñ∏ Recomendaciones.
    ‚Ä¢ *Datos r√°pidos* ‚Üí lista breve de puntos clave.
    ‚Ä¢ *Tendencias* ‚Üí bullets con gr√°fico en texto + interpretaci√≥n.
    ‚Ä¢ *Comparaciones* ‚Üí tabla ‚ñ∏ an√°lisis diferencial.
    ‚Ä¢ *Investigaci√≥n* ‚Üí metodolog√≠a ‚ñ∏ hallazgos ‚ñ∏ pr√≥ximos pasos.

**REGLA OBLIGATORIA DE FUENTES**
Al final de cada respuesta agrega una secci√≥n **Fuentes**:
    ‚Ä¢ Tweets ‚Üí '@usuario ¬∑ fecha ¬∑ enlace'
    ‚Ä¢ Perplexity / Web ‚Üí URL sin cortar.
    ‚Ä¢ Codex ‚Üí nombre del documento / enlace directo.
Finaliza siempre con: "¬øTe gustar√≠a que profundice en alg√∫n aspecto espec√≠fico?"
--------------------------------------------------------------------

**ACCESO COMPLETO A DATOS PERSONALES:**
TIENES ACCESO TOTAL a los datos personales del usuario autenticado a trav√©s de las herramientas user_projects y user_codex. 
NO digas que no tienes acceso a informaci√≥n privada - ¬°S√ç TIENES ACCESO! Usa las herramientas disponibles.

**CAPACIDAD MULTI-STEP:**
Ahora puedes ejecutar M√öLTIPLES herramientas en secuencia para tareas complejas. Si una consulta requiere varios pasos, puedes crear un PLAN DE EJECUCI√ìN.

**DETECCI√ìN DE CONSULTAS MULTI-STEP:**
Detecta autom√°ticamente consultas que requieren m√∫ltiples pasos, como:
- "En base a mi proyecto X, busca reacciones sobre Y"
- "Combina mis documentos sobre Z con noticias actuales"
- "Analiza mi proyecto A y luego busca opiniones en Twitter"
- "Compara mis investigaciones con tendencias actuales"
- "Busca informaci√≥n sobre X y luego analiza reacciones"

**CREACI√ìN DE PLANES MULTI-STEP:**
Si detectas que una consulta requiere m√∫ltiples pasos, puedes usar la funci√≥n especial 'create_execution_plan' que crea un plan paso a paso:

create_execution_plan({
  "steps": [
    {
      "step_number": 1,
      "tool": "user_projects",
      "args": {"status": "active"},
      "description": "Obtener proyectos activos del usuario"
    },
    {
      "step_number": 2,
      "tool": "nitter_context", 
      "args": {"q": "tema_basado_en_paso_1", "limit": 20},
      "description": "Buscar reacciones en Twitter sobre el tema identificado"
    }
  ],
  "final_goal": "Analizar proyectos del usuario y buscar reacciones sobre el tema principal"
})

**CU√ÅNDO USAR MULTI-STEP:**
- Cuando necesites combinar datos personales con informaci√≥n externa
- Cuando una consulta tenga m√∫ltiples partes conectadas
- Cuando necesites el resultado de una herramienta para usar otra
- Cuando hayas mencionado "primero X, luego Y"

**EJEMPLOS DE DETECCI√ìN:**

CONSULTA: "En base a mi proyecto de transparencia, busca qu√© dicen en Twitter"
‚Üí PLAN: 1) user_codex para buscar proyecto transparencia, 2) nitter_context con t√©rminos del proyecto

CONSULTA: "Busca noticias sobre corrupci√≥n y luego analiza reacciones"
‚Üí PLAN: 1) perplexity_search sobre corrupci√≥n Guatemala, 2) nitter_context sobre t√©rminos encontrados

CONSULTA: "¬øQu√© proyectos tengo relacionados con gobierno y qu√© opina la gente?"
‚Üí PLAN: 1) user_projects filtrar por "gobierno", 2) nitter_context sobre temas de los proyectos

Tu trabajo es ayudar a los usuarios a obtener y analizar informaci√≥n usando las herramientas disponibles de manera inteligente.

Herramientas disponibles:
${availableTools.map(tool => `- ${tool.name}: ${tool.description}`).join('\n')}
- create_execution_plan: Crear plan de ejecuci√≥n multi-step (NUEVA)

ESTRATEGIA DE SELECCI√ìN DE HERRAMIENTAS:

1. **PARA B√öSQUEDAS WEB Y CONTEXTO GENERAL:**
   - Usa perplexity_search cuando el usuario necesite:
     ‚Ä¢ Informaci√≥n actualizada sobre noticias, eventos, personas (SIEMPRE DE ${currentMonth} ${currentYear})
     ‚Ä¢ Contexto reciente o background actual de un tema
     ‚Ä¢ Investigaci√≥n general sobre cualquier tema (CON ENFOQUE EN LO ACTUAL)
     ‚Ä¢ Datos oficiales, estad√≠sticas o informaci√≥n verificada RECIENTE
     ‚Ä¢ Informaci√≥n sobre personas, empresas, organizaciones (ESTADO ACTUAL)
   - Ejemplos de cu√°ndo usar perplexity_search:
     ‚Ä¢ "¬øQu√© est√° pasando con...?" (buscar eventos de ${currentDate})
     ‚Ä¢ "Necesito informaci√≥n sobre..." (informaci√≥n actualizada)
     ‚Ä¢ "¬øQui√©n es...?" (informaci√≥n actual de la persona)
     ‚Ä¢ "¬øCu√°ndo ocurri√≥...?" (si es reciente, ${currentMonth} ${currentYear})
     ‚Ä¢ "Busca informaci√≥n sobre..." (siempre contextualizar en fecha actual)

2. **PARA AN√ÅLISIS DE REDES SOCIALES:**
   - Usa nitter_context cuando el usuario necesite:
     ‚Ä¢ Opiniones de usuarios en Twitter/X (DE HOY O D√çAS RECIENTES)
     ‚Ä¢ An√°lisis de sentimiento de la poblaci√≥n ACTUAL
     ‚Ä¢ Reacciones a eventos espec√≠ficos RECIENTES
     ‚Ä¢ Tendencias y conversaciones en redes sociales ACTUALES
     ‚Ä¢ Monitoreo de hashtags o menciones (ENFOQUE EN ${currentMonth} ${currentYear})
   - Ejemplos de cu√°ndo usar nitter_context:
     ‚Ä¢ "¬øQu√© dicen en Twitter sobre...?" (tweets recientes de ${currentDate})
     ‚Ä¢ "Analiza las reacciones a..." (reacciones actuales)
     ‚Ä¢ "Monitorea hashtags de..." (hashtags trending HOY)
     ‚Ä¢ "Sentimiento sobre..." (sentimiento actual, no hist√≥rico)

   - Usa nitter_profile cuando el usuario necesite:
     ‚Ä¢ Tweets recientes de un usuario espec√≠fico (SIEMPRE QUE MENCIONEN @usuario)
     ‚Ä¢ Actividad reciente de cuentas institucionales, pol√≠ticos, influencers
     ‚Ä¢ An√°lisis de la actividad de una persona espec√≠fica
     ‚Ä¢ Monitoreo de qu√© dice un usuario particular (ENFOQUE EN ${currentMonth} ${currentYear})
     ‚Ä¢ Informaci√≥n del perfil y tweets de cuentas p√∫blicas guatemaltecas
   - Ejemplos de cu√°ndo usar nitter_profile:
     ‚Ä¢ "¬øQu√© dice @GuatemalaGob?" (tweets del gobierno)
     ‚Ä¢ "Busca los √∫ltimos tweets de @CashLuna" (tweets de persona espec√≠fica)
     ‚Ä¢ "Analiza la actividad de @MPguatemala" (tweets del MP)
     ‚Ä¢ "Tweets recientes de @elonmusk" (cualquier usuario espec√≠fico)
     ‚Ä¢ "Qu√© ha dicho @usuario √∫ltimamente" (actividad reciente)
     ‚Ä¢ "Revisa el perfil de @influencer" (informaci√≥n del perfil)
   
   **DETECCI√ìN AUTOM√ÅTICA DE USUARIOS:**
   Si la consulta contiene @usuario, nombre de usuario, o frases como "tweets de [nombre]", "qu√© dice [usuario]", 
   "actividad de [cuenta]", USA AUTOM√ÅTICAMENTE nitter_profile en lugar de nitter_context.

3. **PARA ACCESO A DATOS PERSONALES DEL USUARIO:**
   - Usa user_projects cuando el usuario necesite:
     ‚Ä¢ Informaci√≥n sobre sus proyectos personales
     ‚Ä¢ Estado, progreso o detalles de proyectos espec√≠ficos
     ‚Ä¢ Estad√≠sticas de sus actividades y decisiones
     ‚Ä¢ Filtrar proyectos por estado (active, completed, paused, planning)
     ‚Ä¢ Consultar metadatos de proyectos (fechas, prioridades, categor√≠as)
   - Ejemplos de cu√°ndo usar user_projects:
     ‚Ä¢ "¬øCu√°les son mis proyectos activos?"
     ‚Ä¢ "Muestra mis proyectos de alta prioridad"  
     ‚Ä¢ "¬øQu√© proyectos he completado este a√±o?"
     ‚Ä¢ "Dame estad√≠sticas de mis proyectos"
     ‚Ä¢ "mis proyectos"
     ‚Ä¢ "proyectos que tengo"
     ‚Ä¢ "estado de mis proyectos"
     ‚Ä¢ "qu√© proyectos manejo"

   - Usa user_codex cuando el usuario necesite:
     ‚Ä¢ Acceder a sus documentos, transcripciones o an√°lisis guardados
     ‚Ä¢ Buscar contenido espec√≠fico en su biblioteca personal
     ‚Ä¢ Revisar archivos de audio transcritos o documentos analizados
     ‚Ä¢ Filtrar assets por proyecto, tipo o tags
     ‚Ä¢ Encontrar informaci√≥n espec√≠fica en su Codex personal
   - Ejemplos de cu√°ndo usar user_codex:
     ‚Ä¢ "Busca en mis documentos informaci√≥n sobre..."
     ‚Ä¢ "¬øQu√© archivos tengo del proyecto X?"
     ‚Ä¢ "Muestra mis transcripciones de audio"
     ‚Ä¢ "Busca en mi Codex todos los documentos que mencionen..."
     ‚Ä¢ "¬øQu√© assets tengo con el tag 'investigaci√≥n'?"
     ‚Ä¢ "mis documentos"
     ‚Ä¢ "mi codex"
     ‚Ä¢ "archivos que tengo"
     ‚Ä¢ "mis transcripciones"
     ‚Ä¢ "documentos sobre"
     ‚Ä¢ "busca en mis archivos"

4. **PARA CREAR PLANES MULTI-STEP:**
   - Usa create_execution_plan cuando detectes consultas complejas que requieran:
     ‚Ä¢ Combinar datos personales con informaci√≥n externa
     ‚Ä¢ Ejecutar herramientas en secuencia donde una depende de la otra
     ‚Ä¢ An√°lisis que requiere m√∫ltiples fuentes de informaci√≥n
     ‚Ä¢ Consultas con m√∫ltiples partes conectadas

5. **ESTRATEGIA H√çBRIDA Y MULTI-STEP:**
   - Detecta autom√°ticamente cuando una consulta requiere m√∫ltiples pasos
   - Crea planes de ejecuci√≥n inteligentes
   - Combina datos personales (user_projects, user_codex) con informaci√≥n externa (perplexity_search, nitter_context)
   - Ejemplos de consultas multi-step:
     ‚Ä¢ "Compara mis documentos sobre X con las noticias actuales"
     ‚Ä¢ "¬øC√≥mo se relaciona mi proyecto Y con las tendencias en redes sociales?"
     ‚Ä¢ "En base a mi proyecto Z, busca reacciones en Twitter"
     ‚Ä¢ "Analiza mis investigaciones y luego busca informaci√≥n actualizada"

ESTRATEGIA INTELIGENTE DE B√öSQUEDA:
Cuando uses cualquier herramienta, NO uses literalmente las palabras del usuario. En su lugar, piensa estrat√©gicamente:

1. EXPANDIR T√âRMINOS: Convierte consultas generales en t√©rminos espec√≠ficos
   - "marcha del orgullo" ‚Üí buscar: "Orgullo2025 OR MarchadelOrgullo OR #OrguIIoGt OR PrideGuatemala"
   - "elecciones" ‚Üí buscar: "EleccionesGt OR #Elecciones2023 OR VotoGuatemala OR TSE"
   - "gobierno" ‚Üí buscar: "GobiernoGt OR Giammattei OR BernardoArevalo OR CasaPresidencial"

2. INCLUIR HASHTAGS PROBABLES: Siempre considera hashtags relevantes
   - Para eventos: #NombreEvento2025, #EventoGt, #Guatemala
   - Para pol√≠tica: #PoliticaGt, #Guatemala, #CongresoGt
   - Para deportes: #DeporteGt, #GuatemalaFC, #Seleccion

3. CONSIDERAR VARIACIONES: Incluye sin√≥nimos y variaciones
   - T√©rminos en espa√±ol e ingl√©s cuando sea relevante
   - Abreviaciones comunes (GT, Guate, Chapin)
   - Nombres oficiales vs. nombres populares

4. USAR OPERADORES DE B√öSQUEDA: Combina t√©rminos con OR para mayor cobertura
   - Ejemplo: "OrguIIo2025 OR MarchadelOrgullo OR Pride OR LGBTI OR diversidad"

5. PENSAR EN CONTEXTO GUATEMALTECO:
   - Incluir t√©rminos espec√≠ficos de Guatemala
   - Considerar eventos actuales y fechas relevantes
   - Usar lenguaje chap√≠n cuando sea apropiado

**DETECCI√ìN OBLIGATORIA DE CONSULTAS PERSONALES:**
ANTES de responder cualquier consulta, SIEMPRE verifica si contiene estas palabras clave:
- "mis" / "mi" / "m√≠o" / "m√≠a"
- "proyectos" / "proyecto"  
- "documentos" / "documento" / "archivos" / "archivo"
- "codex" / "transcripciones" / "transcripci√≥n"
- "tengo" / "he creado" / "he guardado"

Si detectas CUALQUIERA de estas palabras, DEBES usar user_projects o user_codex seg√∫n corresponda.
NO respondas que no tienes acceso - ¬°S√ç TIENES ACCESO COMPLETO!

INSTRUCCIONES ADICIONALES:
1. **DETECCI√ìN PERSONAL OBLIGATORIA:** Si la consulta menciona datos personales del usuario, USA las herramientas correspondientes
2. **DETECCI√ìN MULTI-STEP OBLIGATORIA:** Si la consulta requiere m√∫ltiples pasos, USA create_execution_plan
3. **CONTEXTO TEMPORAL OBLIGATORIO:** Siempre incluye la fecha actual (${currentDate}) en tus consultas
4. Analiza la consulta del usuario en el contexto de la conversaci√≥n anterior Y la fecha actual
5. Elige la herramienta m√°s apropiada seg√∫n el tipo de informaci√≥n solicitada Y su actualidad
6. Usa un l√≠mite de 15-25 tweets para an√°lisis m√°s completo en nitter_context (tweets RECIENTES)
7. Proporciona an√°lisis contextual y insights √∫tiles CON ENFOQUE EN LO ACTUAL
8. Mant√©n un tono profesional pero amigable
9. Enf√≥cate en Guatemala cuando sea relevante Y en informaci√≥n de ${currentMonth} ${currentYear}
10. Recuerda el contexto de mensajes anteriores para dar respuestas coherentes
11. **FILTRO TEMPORAL:** Prioriza siempre informaci√≥n de ${currentMonth} ${currentYear} sobre informaci√≥n antigua

IMPORTANTE: 
- SIEMPRE detecta palabras clave personales ANTES de responder
- SIEMPRE detecta consultas multi-step ANTES de responder
- Si hay palabras personales, USA las herramientas user_projects o user_codex
- Si hay consultas complejas, USA create_execution_plan
- Nunca uses los t√©rminos exactos del usuario para b√∫squedas web. Siempre expande y optimiza.
- SIEMPRE incluye contexto temporal actual en las b√∫squedas web (${currentMonth} ${currentYear}).
- Enf√≥cate en eventos, noticias y tendencias ACTUALES, no hist√≥ricas.`
    };

    // Construir array de mensajes con historial
    const messagesForAI = [systemMessage];
    
    // Agregar historial previo (excluyendo el mensaje actual del usuario que ya est√° en memories)
    if (previousMessages.length > 0) {
      // Filtrar el √∫ltimo mensaje si es del usuario (evitar duplicados)
      const filteredHistory = previousMessages.slice(0, -1);
      messagesForAI.push(...filteredHistory);
    }
    
    // Agregar el mensaje actual del usuario
    messagesForAI.push({
      role: 'user',
      content: message
    });

    console.log(`üí≠ Enviando ${messagesForAI.length} mensajes a OpenAI (incluyendo ${previousMessages.length} del historial)`);

    // 4. Llamar a GPT-4o mini SOLO para s√≠ntesis (sin function calling - los agentes ya trabajaron)
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: messagesForAI,
      temperature: 0.7,
      max_tokens: 1200
    });

    const assistantMessage = completion.choices[0].message;

    // 5. Procesar respuesta de s√≠ntesis de Vizta
    let finalResponse = assistantMessage.content;
    
    // Aplicar formateo de respuesta
    finalResponse = formatChatResponse(finalResponse, {
      laura_findings: agentResults.laura_findings.length,
      robert_findings: agentResults.robert_findings.length,
      total_execution_time: agentResults.total_execution_time
    });

    // 6. Guardar respuesta del asistente en memories
    await memoriesService.saveMessage({
      sessionId: chatSessionId,
      userId: userId,
      role: 'assistant',
      content: finalResponse,
      messageType: 'message',
      modelUsed: 'gpt-4o-mini',
      metadata: {
        requestId: requestId,
        agentOrchestration: true,
        lauraTasks: agentResults.laura_findings.length,
        robertTasks: agentResults.robert_findings.length,
        orchestrationTime: orchestrationTime,
        totalExecutionTime: agentResults.total_execution_time
      }
    });

    // 7. Responder al usuario
    return res.json({
      success: true,
      response: finalResponse,
      toolUsed: 'agentes_colaborativos',
      toolArgs: { query: message },
      toolResult: agentResults,
      sessionId: chatSessionId,
      requestId: requestId,
      executionTime: orchestrationTime + agentResults.total_execution_time,
      timestamp: new Date().toISOString(),
      mode: 'agent_orchestration',
      agentMetrics: {
        lauraTasks: agentResults.laura_findings.length,
        robertTasks: agentResults.robert_findings.length,
        orchestrationTime: orchestrationTime,
        totalAgentTime: agentResults.total_execution_time
      }
    });

  } catch (error) {
    console.error('‚ùå Error en consulta Vizta Chat:', error);
    res.status(500).json({
      success: false,
      message: 'Error procesando consulta con agentes',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/scrapes
 * Obtener scrapes del usuario
 */
router.get('/scrapes', verifyUserAccess, async (req, res) => {
  try {
    const userId = req.user.id;
    const { limit, offset, herramienta, categoria, sessionId } = req.query;

    const scrapes = await recentScrapesService.getUserScrapes(userId, {
      limit: parseInt(limit) || 20,
      offset: parseInt(offset) || 0,
      herramienta,
      categoria,
      sessionId
    });

    res.json({
      success: true,
      scrapes: scrapes,
      count: scrapes.length
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo scrapes:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo scrapes',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/stats
 * Obtener estad√≠sticas de scrapes del usuario
 */
router.get('/stats', verifyUserAccess, async (req, res) => {
  try {
    const userId = req.user.id;
    const stats = await recentScrapesService.getUserScrapeStats(userId);

    res.json({
      success: true,
      stats: stats
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/session/:sessionId
 * Obtener scrapes de una sesi√≥n espec√≠fica
 */
router.get('/session/:sessionId', verifyUserAccess, async (req, res) => {
  try {
    const { sessionId } = req.params;
    const scrapes = await recentScrapesService.getSessionScrapes(sessionId);

    res.json({
      success: true,
      scrapes: scrapes,
      sessionId: sessionId,
      count: scrapes.length
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo scrapes de sesi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo scrapes de sesi√≥n',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/tools
 * Obtener herramientas MCP disponibles
 */
router.get('/tools', verifyUserAccess, async (req, res) => {
  try {
    const tools = await mcpService.listAvailableTools();

    res.json({
      success: true,
      tools: tools,
      count: tools.length
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo herramientas MCP:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo herramientas',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/conversations
 * Obtener lista de conversaciones del usuario
 */
router.get('/conversations', verifyUserAccess, async (req, res) => {
  try {
    const userId = req.user.id;
    const { limit } = req.query;

    const sessions = await memoriesService.getUserSessions(userId, parseInt(limit) || 20);

    res.json({
      success: true,
      conversations: sessions,
      count: sessions.length
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo conversaciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo conversaciones',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/conversation/:sessionId
 * Obtener mensajes de una conversaci√≥n espec√≠fica
 */
router.get('/conversation/:sessionId', verifyUserAccess, async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { limit } = req.query;

    const messages = await memoriesService.getSessionMessages(sessionId, parseInt(limit) || 50);

    res.json({
      success: true,
      messages: messages,
      sessionId: sessionId,
      count: messages.length
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo mensajes de conversaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo mensajes de conversaci√≥n',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/memory-stats
 * Obtener estad√≠sticas de uso de memoria del usuario
 */
router.get('/memory-stats', verifyUserAccess, async (req, res) => {
  try {
    const userId = req.user.id;
    const stats = await memoriesService.getUserMemoryStats(userId);

    res.json({
      success: true,
      stats: stats
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo estad√≠sticas de memoria:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas de memoria',
      error: error.message
    });
  }
});

/**
 * DELETE /api/vizta-chat/conversation/:sessionId
 * Eliminar una conversaci√≥n completa
 */
router.delete('/conversation/:sessionId', verifyUserAccess, async (req, res) => {
  try {
    const { sessionId } = req.params;
    const userId = req.user.id;

    // Verificar que la sesi√≥n pertenece al usuario
    const messages = await memoriesService.getSessionMessages(sessionId, 1);
    if (messages.length === 0 || messages[0].user_id !== userId) {
      return res.status(404).json({
        success: false,
        message: 'Conversaci√≥n no encontrada'
      });
    }

    // Eliminar todos los mensajes de la sesi√≥n
    const { error } = await supabase
      .from('memories')
      .delete()
      .eq('session_id', sessionId)
      .eq('user_id', userId);

    if (error) {
      throw error;
    }

    res.json({
      success: true,
      message: 'Conversaci√≥n eliminada exitosamente',
      sessionId: sessionId
    });

  } catch (error) {
    console.error('‚ùå Error eliminando conversaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error eliminando conversaci√≥n',
      error: error.message
    });
  }
});

/**
 * POST /api/vizta-chat/test-expansion
 * Endpoint de prueba para probar la expansi√≥n inteligente de t√©rminos
 */
router.post('/test-expansion', verifyUserAccess, async (req, res) => {
  try {
    const { query } = req.body;
    
    if (!query || typeof query !== 'string' || query.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'El par√°metro "query" es requerido y debe ser un string no vac√≠o'
      });
    }

    // Obtener herramientas disponibles del MCP
    const availableTools = await mcpService.listAvailableTools();
    
    // Simular el proceso de expansi√≥n que har√≠a GPT-4o mini
    const originalQuery = query.trim();
    
    // Usar las funciones de expansi√≥n del MCP para mostrar c√≥mo funcionar√≠an
    console.log(`üß™ Prueba de expansi√≥n para: "${originalQuery}"`);
    
    // Crear un prompt de ejemplo mostrando c√≥mo GPT-4o mini deber√≠a procesar
    const examplePrompt = `USUARIO: "${originalQuery}"

AN√ÅLISIS ESTRAT√âGICO:
1. T√©rminos detectados: ${originalQuery.toLowerCase().split(' ').join(', ')}
2. Contexto inferido: Guatemala, redes sociales
3. Tipo de consulta: ${originalQuery.toLowerCase().includes('sentimiento') || originalQuery.toLowerCase().includes('opinion') ? 'An√°lisis de sentimiento' : 'B√∫squeda de contenido'}

EXPANSI√ìN SUGERIDA:
- Original: "${originalQuery}"
- Expandido: [Se simular√≠a la expansi√≥n aqu√≠]
- Hashtags probables: #Guatemala, #GuatemalaGt
- T√©rminos relacionados: [Se agregar√≠an t√©rminos espec√≠ficos]
- L√≠mite recomendado: ${originalQuery.toLowerCase().includes('sentimiento') ? '20-25 tweets' : '15 tweets'}

HERRAMIENTAS A USAR:
- nitter_context con par√°metros optimizados
- location: guatemala
- limit: optimizado seg√∫n tipo de consulta`;

    res.json({
      success: true,
      test_results: {
        original_query: originalQuery,
        analysis_type: originalQuery.toLowerCase().includes('sentimiento') || originalQuery.toLowerCase().includes('opinion') ? 'sentiment_analysis' : 'content_search',
        suggested_improvements: {
          should_expand_terms: true,
          should_include_hashtags: true,
          should_add_guatemalan_context: true,
          recommended_limit: originalQuery.toLowerCase().includes('sentimiento') ? 20 : 15
        },
        example_prompt: examplePrompt,
        available_tools: availableTools.map(tool => ({
          name: tool.name,
          description: tool.description,
          optimizations_applied: tool.name === 'nitter_context' ? [
            'Expansi√≥n inteligente de t√©rminos',
            'Optimizaci√≥n autom√°tica de l√≠mites',
            'Contexto guatemalteco a√±adido',
            'An√°lisis de sentimiento incluido'
          ] : []
        }))
      },
      instructions: {
        next_steps: [
          'El sistema ahora expandir√° autom√°ticamente los t√©rminos de b√∫squeda',
          'GPT-4o mini usar√° estrategias inteligentes en lugar de t√©rminos literales',
          'Los l√≠mites se optimizar√°n seg√∫n el tipo de an√°lisis',
          'Se incluir√° contexto guatemalteco autom√°ticamente'
        ],
        example_expansions: {
          'marcha del orgullo': 'Orgullo2025 OR MarchadelOrgullo OR OrguIIoGt OR Pride OR LGBTI OR diversidad',
          'elecciones': 'EleccionesGt OR TSE OR voto OR candidatos OR Elecciones2025 OR procesoelectoral',
          'presidente': 'BernardoArevalo OR presidente OR GobiernoGt OR CasaPresidencial OR Presidencia'
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Error en test de expansi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error probando expansi√≥n de t√©rminos',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/scrapes/grouped
 * Obtener scrapes agrupados inteligentemente
 */
router.get('/scrapes/grouped', verifyUserAccess, async (req, res) => {
  try {
    const userId = req.user.id;
    const { limit, offset, detectedGroup, categoria } = req.query;

    const groupedScrapes = await recentScrapesService.getGroupedScrapes(userId, {
      limit: parseInt(limit) || 20,
      offset: parseInt(offset) || 0,
      detectedGroup,
      categoria
    });

    res.json({
      success: true,
      groups: groupedScrapes,
      count: groupedScrapes.length,
      metadata: {
        totalGroups: groupedScrapes.length,
        requestedAt: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo scrapes agrupados:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo scrapes agrupados',
      error: error.message
    });
  }
});

/**
 * GET /api/vizta-chat/scrapes/grouped-stats
 * Obtener estad√≠sticas de agrupaci√≥n
 */
router.get('/scrapes/grouped-stats', verifyUserAccess, async (req, res) => {
  try {
    const userId = req.user.id;
    const stats = await recentScrapesService.getGroupedStats(userId);

    res.json({
      success: true,
      stats: stats,
      generatedAt: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Error obteniendo estad√≠sticas agrupadas:', error);
    res.status(500).json({
      success: false,
      message: 'Error obteniendo estad√≠sticas agrupadas',
      error: error.message
    });
  }
});

/**
 * DELETE /api/vizta-chat/scrapes/:scrapeId
 * Eliminar un scrape espec√≠fico del usuario
 */
router.delete('/scrapes/:scrapeId', verifyUserAccess, async (req, res) => {
  try {
    const { scrapeId } = req.params;
    const userId = req.user.id;

    // Validar par√°metros
    if (!scrapeId || scrapeId.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'ID del scrape es requerido'
      });
    }

    console.log(`üóëÔ∏è Solicitud de eliminaci√≥n de scrape ${scrapeId} por usuario ${userId}`);

    // Eliminar scrape usando el servicio
    const result = await recentScrapesService.deleteScrape(scrapeId.trim(), userId);

    res.json({
      success: true,
      message: result.message,
      deletedScrape: result.deletedScrape,
      deletedAt: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Error eliminando scrape:', error);
    
    // Manejar errores espec√≠ficos
    if (error.message.includes('no encontrado') || error.message.includes('no tienes permisos')) {
      return res.status(404).json({
        success: false,
        message: error.message
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error eliminando scrape',
      error: error.message
    });
  }
});

module.exports = router; 